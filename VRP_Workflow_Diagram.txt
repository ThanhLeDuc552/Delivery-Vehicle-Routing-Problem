# Vehicle Routing Problem (VRP) - Complete Workflow Diagram

## Mermaid Code for VRP Workflow

```mermaid
graph TD
    %% User Interface Layer
    A[User Input: Customers & Vehicles] --> B[Frontend UI Components]
    B --> C[CustomerPanel: Add Customer Locations & Demands]
    B --> D[VehiclePanel: Configure Vehicle Capacities]
    B --> E[Depot Configuration]
    
    %% Frontend Processing
    C --> F[formatCVRPRequest Function]
    D --> F
    E --> F
    F --> G[Frontend API Call: solveCVRPBackend]
    
    %% Backend API Layer
    G --> H[Backend Server: POST /api/solve-cvrp]
    H --> I[Backend: Validate Request Data]
    I --> J[Backend: Generate Request ID]
    J --> K[Backend: Store Request in Queue]
    K --> L[Backend: Return Request ID to Frontend]
    
    %% Frontend Polling
    L --> M[Frontend: Start Polling for Solution]
    M --> N[Frontend: checkSolutionStatus API Call]
    N --> O[Backend: GET /api/solution/request_id]
    O --> P{Solution Ready?}
    P -->|No| Q[Wait 1 Second]
    Q --> N
    P -->|Yes| R[Frontend: Receive Solution]
    
    %% Agent System (Parallel to Frontend Polling)
    K --> S[Depot Agent: Continuous API Polling]
    S --> T[Depot: GET /api/solve-cvrp?action=poll]
    T --> U{New Request Available?}
    U -->|No| V[Wait 2 Seconds]
    V --> S
    U -->|Yes| W[Depot: Receive API Request Data]
    
    %% Depot Processing
    W --> X[Depot: parseAPIData with Regex]
    X --> Y[Depot: Extract Vehicles & Customers]
    Y --> Z[Depot: sendProblemDataToMRA]
    Z --> AA[Depot: Format Message for MRA]
    
    %% MRA Processing
    AA --> BB[MRA Agent: Receive API_PROBLEM_DATA]
    BB --> CC[MRA: parseAPIProblemData]
    CC --> DD[MRA: Parse Request ID, Vehicles, Customers]
    DD --> EE[MRA: Calculate Distance Matrix]
    EE --> FF[MRA: solveVRPWithChoco]
    
    %% Choco Solver
    FF --> GG[Choco Solver: Build VRP Model]
    GG --> HH[Choco: Define Decision Variables]
    HH --> II[Choco: Add Constraints]
    II --> JJ[Choco: Set Objective Function]
    JJ --> KK[Choco: Find Optimal Solution]
    
    %% Solution Processing
    KK --> LL{MRA: Solution Found?}
    LL -->|No| MM[MRA: Return Empty Solution]
    LL -->|Yes| NN[MRA: Extract Routes & Distances]
    NN --> OO[MRA: sendSolutionBack to Depot]
    
    %% Depot Solution Handling
    OO --> PP[Depot: Receive Solution from MRA]
    PP --> QQ[Depot: sendSolutionToAPI]
    QQ --> RR[Depot: POST /api/solve-cvrp?action=response]
    RR --> SS[Backend: Store Solution for Request ID]
    
    %% Frontend Result Display
    R --> TT[Frontend: parseBackendResponse]
    TT --> UU[Frontend: Convert to Solution Format]
    UU --> VV[SolutionPanel: Display Routes]
    UU --> WW[RouteVisualization: Show Map with Routes]
    UU --> XX[ExportPanel: Download Results]
    
    %% Error Handling
    MM --> OO
    YY[Error: Invalid Data] --> ZZ[Error: Empty Solution]
    ZZ --> OO
    
    %% Styling
    classDef userLayer fill:#e1f5fe
    classDef frontendLayer fill:#f3e5f5
    classDef backendLayer fill:#e8f5e8
    classDef agentLayer fill:#fff3e0
    classDef solverLayer fill:#fce4ec
    classDef resultLayer fill:#f1f8e9
    
    class A,B,C,D,E userLayer
    class F,G,M,N,R,TT,UU frontendLayer
    class H,I,J,K,L,O,P,S,T,U,W,RR,SS backendLayer
    class X,Y,Z,AA,BB,CC,DD,EE,PP,QQ agentLayer
    class FF,GG,HH,II,JJ,KK,LL,NN,OO solverLayer
    class VV,WW,XX resultLayer
```

## Workflow Description

### 1. User Input Phase
- User configures customers (locations, demands) via CustomerPanel
- User sets vehicle capacities via VehiclePanel
- User configures depot settings

### 2. Frontend Processing
- `formatCVRPRequest()` converts UI data to API format
- `solveCVRPBackend()` sends POST request to backend
- Frontend receives request ID and starts polling

### 3. Backend API Layer
- Validates incoming request data
- Generates unique request ID
- Stores request in queue for agent processing
- Returns request ID to frontend

### 4. Agent System (Parallel Processing)
- **Depot Agent**: Continuously polls backend for new requests
- **Depot Processing**: Parses API data using regex patterns
- **Message Formatting**: Converts to MRA-compatible format

### 5. MRA Solver Processing
- **Data Parsing**: Extracts vehicles, customers, coordinates
- **Distance Calculation**: Computes Euclidean distances
- **Choco Solver**: Builds and solves VRP optimization model
- **Solution Extraction**: Formats routes and distances

### 6. Solution Flow Back
- **MRA → Depot**: Sends solution via ACL message
- **Depot → Backend**: Posts solution to API endpoint
- **Backend Storage**: Associates solution with request ID

### 7. Frontend Result Display
- **Polling**: Frontend checks for solution completion
- **Parsing**: Converts backend response to UI format
- **Visualization**: Displays routes on map and in tables
- **Export**: Allows downloading of results

## Key Components

### Frontend (React/TypeScript)
- CustomerPanel, VehiclePanel, SolutionPanel
- API utilities for backend communication
- Route visualization and export functionality

### Backend (Python Flask)
- REST API endpoints for request handling
- Request queue management
- Solution storage and retrieval

### Agent System (JADE)
- **Depot Agent**: API polling and data transformation
- **MRA Agent**: VRP problem solving with Choco solver

### Solver (Choco)
- Constraint programming model for VRP
- Optimization for minimum total distance
- Route generation with capacity constraints

## Data Flow
1. **Input**: Customer coordinates, demands, vehicle capacities
2. **Processing**: API → Depot → MRA → Choco Solver
3. **Output**: Optimized routes with distances and vehicle assignments
4. **Display**: Interactive map visualization and downloadable results

