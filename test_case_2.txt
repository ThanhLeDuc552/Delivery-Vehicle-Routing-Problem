Backend:
1. Hệ thống nhận hàng tự động:
    - List hàng: các customer (agent) sẽ liên tiếp request các mặt hàng
    - Các mặt hàng tự động được depot nhận về và đưa vào một list để xử lý
    - Khi nào số hàng vượt mức nào đó, sẽ lấy số hàng dưới mức đó để đưa vào tính toán
    - Dưới danh nghĩa hàng nma vẫn chỉ implement khối lượng cho việc tính toán đơn giản

2. Hệ thống tính toán quãng đường mới: (chắc lùi qua test case 3, nên tập trung vào multiagent sys)
    - Thay vì chỉ có mỗi distance (khoảng cách toạ độ euclid), thì implement path cost

3. Hệ thống giao tiếp mới cho delivery và vehicle
    - Dùng FIPA-REQUEST cho Depot -> Delivery (đã áp dụng)
    - Dùng payload tối giản: Depot gửi `VEHICLES:name:cap,...`; Delivery trả `NAMES:...`
    - Với Delivery -> Vehicle: sẽ nâng cấp dần (định hướng CONTRACT-NET ở test case 3)

4. Phạm vi (Scope) của Test Case 2 (nâng cấp từ Test Case 1)
    - Tập trung vào hệ thống multi-agent + dây chuyền nhận hàng + tồn kho đơn giản
    - Chưa làm path cost/time window ở mức OR-Tools (để test case 3)
    - Chuẩn hoá giao tiếp Depot <-> Delivery theo FIPA-REQUEST + tối giản payload

6. Quy tắc xử lý đơn hàng ở Depot
    - Nhận request từ các Customer agent và đẩy vào queue
    - Cơ chế backpressure theo ngưỡng N (ví dụ N = 10 yêu cầu):
        - Khi queue >= N, chốt batch hiện tại để tính route
        - Lấy các yêu cầu trong batch, gom theo tọa độ khách + tổng khối lượng (qty ~ demand)
    - Kiểm tồn kho:
        - Nếu `inventory[item] >= qty` thì xác nhận phục vụ, trừ tồn và cộng vào demand của customer tương ứng
        - Nếu thiếu, đẩy phần thiếu vào Unserved, và chỉ lấy phần còn có thể phục vụ (hoặc bỏ qua toàn bộ nếu muốn đơn giản)

7. Định dạng dữ liệu đầu vào/đầu ra (tối giản)
    - Từ Customer -> Depot (giả lập nội bộ trong agent): `{customerId, x, y, requests: [{item, qty}]}`
    - Depot -> Delivery (FIPA-REQUEST): `VEHICLES:name:cap,name2:cap2`
    - Delivery -> Depot (INFORM): `NAMES:name1,name2,...` (trả danh sách xe đang rảnh)
    - Depot -> Delivery (INFORM routes, giữ nguyên JSON route cũ để UI dùng)
    - Delivery -> API: JSON final gồm `vehicle_state`, `available_vehicle_count`, `routes` như hiện tại

9. Tiêu chí chấp nhận (Acceptance Criteria)
    - Có cơ chế queue + ngưỡng batch N cho yêu cầu hàng
    - Kiểm tồn kho đơn giản: có thể phục vụ toàn bộ hoặc một phần; phần thiếu được ghi vào Unserved
    - Giao tiếp Depot <-> Delivery dùng FIPA-REQUEST + payload rút gọn như đã triển khai
    - Kết quả cuối vẫn hiển thị được routes ở frontend như Test Case 1
    - Log đầy đủ các sự kiện chính: nhận yêu cầu, batch chốt, kiểm kho, số xe rảnh, giải route, gửi API


Frontend:







5. Cấu trúc dữ liệu tạm thời (để demo nhanh, chưa dùng DB)
    - Inventory tại Depot: `dict[itemName] = quantity`
    - Inventory mong muốn phía Customer (để mô phỏng): `dict[itemName] = desiredQuantity`
    - Yêu cầu hàng (request queue): list các tuple `{customerId, itemName, qty}`
    - Unserved customers: list các yêu cầu bị thiếu hàng `{customerId, itemName, qtyMissing}`



8. Luồng hoạt động (Workflow)
    1) Customer agents phát sinh request ngẫu nhiên, đẩy vào queue của Depot
    2) Depot duy trì `inventory`, kiểm tra tồn theo request; gom batch khi đạt ngưỡng
    3) Depot hỏi Delivery (FIPA-REQUEST) để lấy danh sách xe rảnh (payload tối giản)
    4) Depot giải CVRP với số xe rảnh (như Test Case 1), routes vẫn theo JSON hiện có
    5) Depot gửi routes cho Delivery; Delivery gán/ghi nhận và chuyển kết quả sang API
    6) Ghi nhận Unserved (thiếu hàng) kèm lý do để UI hiển thị (sau)


10. Kế hoạch triển khai theo bước (phù hợp code hiện tại)
    - B1: Thêm lớp/tiện ích quản lý `inventory` tại Depot (in-memory dict)
    - B2: Thêm queue yêu cầu + cơ chế batch theo ngưỡng N (ticker/behaviour ở Depot)
    - B3: Mapping request -> demand theo customer (tính tổng qty thành demand)
    - B4: Tích hợp flow đã có: hỏi Delivery (NAMES), giải OR-Tools, gửi routes
    - B5: Ghi nhận Unserved và in log; (tùy chọn) đính kèm vào meta của route JSON

11. Gợi ý mở rộng nhanh (nếu còn thời gian ở TC2)
    - Thêm metric: thời gian chờ trong queue, tỉ lệ unserved
    - Simple replay/flush queue qua API debug
    - Tối ưu batch size động theo tốc độ yêu cầu

12. Ghi chú chuyển tiếp Test Case 3
    - Nâng cấp path cost (distance + fuel/time/đường) và time windows vào OR-Tools
    - Chuyển Delivery -> Vehicles sang CONTRACT-NET để “đấu thầu” route

13. Thay đổi CỤ THỂ cần làm ở Frontend
    - API/data format
        - Hỗ trợ gửi request customer-only khi danh sách xe không đổi (đã có từ TC1)
        - Không đổi format routes JSON đầu ra (để tái sử dụng UI)
        - (Tuỳ chọn) Thêm trường `unserved` trong meta để hiển thị yêu cầu thiếu hàng: `{"unserved":[{"customerId":"...","item":"...","qtyMissing":number}]}`
    - UI bổ sung
        - Thêm khối hiển thị Inventory (đọc từ API / hoặc debug mock): danh sách item và số lượng
        - Thêm Notification/Event panel (hiện đã có log ở backend): hiển thị sự kiện chính (batch chốt, số xe rảnh, gửi routes, unserved)
        - Vehicles page (đã đề cập TC1): hiển thị danh sách xe, trạng thái free/absent theo lần request
        - Customers panel: cho phép mô phỏng thêm yêu cầu mặt hàng (tên item + qty) để đẩy vào queue
    - File/code điểm chạm (tham khảo repo frontend hiện tại)
        - `frontend/src/utils/api.ts`: thêm hàm fetch inventory/unserved (nếu backend cung cấp) và gửi customer requests
        - `frontend/src/components/DepotPanel.tsx`: thêm bảng Inventory + Unserved (nếu có trong response/meta)
        - `frontend/src/components/SolutionPanel.tsx` và `RouteVisualization.tsx`: giữ nguyên parsing routes
        - `frontend/src/components/CustomerPanel.tsx`: thêm form “Add item request” để mock request
        - `frontend/src/components/VehiclePanel.tsx` hoặc `VehiclesPage.tsx`: hiển thị trạng thái xe theo response
    - Acceptance UI 
        - Submit dữ liệu như TC1 vẫn chạy được
        - Có thể bấm “Add request” để đẩy yêu cầu hàng giả lập và thấy batch xử lý sau vài giây
        - Thấy Inventory giảm khi phục vụ, Unserved tăng khi thiếu

14. Thay đổi CỤ THỂ cần làm ở Agents (Java/JADE)
    - Depot Agent
        - Thêm cấu trúc `inventory: Map<String,Integer>` và API nội bộ để tăng/giảm tồn
        - Thêm queue yêu cầu: `List<Request>`, kiểu `Request{customerId:String, x:double, y:double, items: List<ItemQty>}`
        - Thêm behaviour ticker để: gom batch khi queue >= N; kiểm tồn, tách phần phục vụ được vs unserved
        - Mapping batch -> dữ liệu solver như hiện tại: gộp theo customer, `demand = tổng qty phục vụ được`
        - Gửi FIPA-REQUEST (payload tối giản) tới Delivery và nhận `NAMES:...`
        - Chèn `unserved` vào meta JSON (tuỳ chọn) trước khi gửi Delivery
        - (Tuỳ chọn) Expose 1 endpoint phụ ở backend Python để trả inventory/unserved cho UI
    - Delivery Agent
        - Đã chuyển sang FIPA-REQUEST với payload tối giản; giữ nguyên logic truy vấn state xe
        - Bảo toàn `protocol` + `conversationId` khi trả `NAMES:...`
        - Khi nhận routes từ Depot: không đổi format; tiếp tục forward sang API
    - Vehicle Agent
        - Giữ MESSAGE hiện tại: `QUERY_STATE` trả `STATE|CAPACITY|NAME`
        - (Sau TC3) Sẵn sàng refactor sang Contract-Net cho gán route
    - Customer Agent (mock)
        - Tạo agent đơn giản phát sinh request ngẫu nhiên (item/qty) mỗi T giây, push vào Depot bằng ACL (nội bộ)
        - Hoặc thay bằng một behaviour trong Depot để sinh request giả lập nếu chưa tạo Customer agent hoàn chỉnh

15. Checklist triển khai nhanh
    - [ ] Depot: inventory + queue + batch behaviour (N cấu hình)
    - [ ] Depot: kiểm tồn + tạo danh sách unserved cho batch
    - [ ] Depot <-> Delivery: payload tối giản, đã có FIPA-REQUEST
    - [ ] Depot: build demand từ batch và chạy solver như TC1
    - [ ] Delivery: forward kết quả sang API như hiện tại
    - [ ] Frontend: hiển thị Inventory + Unserved + Event log; form add request